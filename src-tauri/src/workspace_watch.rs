use std::{
    fs,
    path::{Path, PathBuf},
    sync::{Arc, Mutex, OnceLock},
    time::{SystemTime, UNIX_EPOCH},
};

use ignore::gitignore::{Gitignore, GitignoreBuilder};
use notify::{
    event::{EventKind, ModifyKind, RenameMode},
    RecommendedWatcher, RecursiveMode, Watcher,
};
use serde::Serialize;
use tauri::{AppHandle, Emitter};

use crate::{AppError, Result};

const INTERNAL_DIR_NAME: &str = ".tomosona";
const TRASH_DIR_NAME: &str = ".tomosona-trash";
const DB_FILE_NAME: &str = "tomosona.sqlite";
const GITIGNORE_FILE_NAME: &str = ".gitignore";
const TOMOSONA_IGNORE_FILE_NAME: &str = ".tomosonaignore";
const FS_EVENT_NAME: &str = "workspace://fs-changed";

#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub(crate) enum WorkspaceFsChangeKind {
    Created,
    Removed,
    Renamed,
    Modified,
}

#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
pub(crate) struct WorkspaceFsChange {
    pub kind: WorkspaceFsChangeKind,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub old_parent: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_parent: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_dir: Option<bool>,
}

#[derive(Debug, Clone, Serialize)]
pub(crate) struct WorkspaceFsChangedPayload {
    pub session_id: u64,
    pub root: String,
    pub changes: Vec<WorkspaceFsChange>,
    pub ts_ms: u64,
}

#[derive(Debug)]
struct WorkspaceWatcherState {
    session_id: u64,
    root: Option<PathBuf>,
    watcher: Option<RecommendedWatcher>,
}

impl Default for WorkspaceWatcherState {
    fn default() -> Self {
        Self {
            session_id: 0,
            root: None,
            watcher: None,
        }
    }
}

fn watcher_state() -> &'static Mutex<WorkspaceWatcherState> {
    static WATCHER_STATE: OnceLock<Mutex<WorkspaceWatcherState>> = OnceLock::new();
    WATCHER_STATE.get_or_init(|| Mutex::new(WorkspaceWatcherState::default()))
}

fn normalize_slashes(path: &Path) -> String {
    path.to_string_lossy().replace('\\', "/")
}

fn root_contains_path(root: &str, path: &str) -> bool {
    path == root || path.starts_with(&format!("{root}/"))
}

fn path_parent(path: &str) -> Option<String> {
    path.rsplit_once('/').map(|(parent, _)| parent.to_string())
}

fn skip_file_name(file_name: &str) -> bool {
    file_name == DB_FILE_NAME || file_name.starts_with("tomosona.sqlite-")
}

fn should_skip_path(path: &Path) -> bool {
    let Some(file_name) = path.file_name().and_then(|value| value.to_str()) else {
        return false;
    };

    if skip_file_name(file_name) {
        return true;
    }

    path.components().any(|component| {
        let part = component.as_os_str().to_string_lossy();
        part == INTERNAL_DIR_NAME || part == TRASH_DIR_NAME
    })
}

fn build_ignore_matcher(root: &Path) -> Option<Gitignore> {
    let mut builder = GitignoreBuilder::new(root);

    let gitignore = root.join(GITIGNORE_FILE_NAME);
    if gitignore.is_file() {
        builder.add(gitignore);
    }

    let tomosona_ignore = root.join(TOMOSONA_IGNORE_FILE_NAME);
    if tomosona_ignore.is_file() {
        builder.add(tomosona_ignore);
    }

    builder.build().ok()
}

fn is_ignored_by_matcher(
    root: &Path,
    matcher: Option<&Gitignore>,
    path: &Path,
    is_dir: bool,
) -> bool {
    let Some(matcher) = matcher else {
        return false;
    };

    let canonical_root = fs::canonicalize(root).unwrap_or_else(|_| root.to_path_buf());

    let candidate = if path.is_absolute() {
        path.to_path_buf()
    } else {
        canonical_root.join(path)
    };

    let canonical_candidate = fs::canonicalize(&candidate).unwrap_or(candidate);
    let Ok(relative) = canonical_candidate.strip_prefix(&canonical_root) else {
        return false;
    };

    matcher
        .matched_path_or_any_parents(relative, is_dir)
        .is_ignore()
}

fn should_skip_event_path(
    root: &Path,
    matcher: Option<&Gitignore>,
    path: &Path,
    is_dir: bool,
) -> bool {
    should_skip_path(path) || is_ignored_by_matcher(root, matcher, path, is_dir)
}

fn normalize_event_path(raw: &Path, root_path: &Path, root_normalized: &str) -> Option<String> {
    let candidate = if raw.is_absolute() {
        raw.to_path_buf()
    } else {
        root_path.join(raw)
    };

    let normalized = normalize_slashes(&candidate);
    if !root_contains_path(root_normalized, &normalized) {
        return None;
    }
    Some(normalized)
}

fn maybe_is_dir(path: &Path) -> Option<bool> {
    if let Ok(meta) = fs::metadata(path) {
        return Some(meta.is_dir());
    }

    if path.extension().is_none() {
        Some(true)
    } else {
        None
    }
}

fn build_payload(
    session_id: u64,
    root_normalized: &str,
    changes: Vec<WorkspaceFsChange>,
) -> WorkspaceFsChangedPayload {
    let ts_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|value| value.as_millis() as u64)
        .unwrap_or(0);

    WorkspaceFsChangedPayload {
        session_id,
        root: root_normalized.to_string(),
        changes,
        ts_ms,
    }
}

fn emit_changes(
    app_handle: &AppHandle,
    session_id: u64,
    root_normalized: &str,
    changes: Vec<WorkspaceFsChange>,
) {
    if changes.is_empty() {
        return;
    }

    let payload = build_payload(session_id, root_normalized, changes);
    let _ = app_handle.emit(FS_EVENT_NAME, payload);
}

fn handle_notify_event(
    app_handle: &AppHandle,
    session_id: u64,
    root_path: &Path,
    root_normalized: &str,
    matcher: Option<&Gitignore>,
    event: notify::Event,
) {
    let changes = map_notify_event_to_changes(root_path, root_normalized, matcher, event);
    emit_changes(app_handle, session_id, root_normalized, changes);
}

fn map_notify_event_to_changes(
    root_path: &Path,
    root_normalized: &str,
    matcher: Option<&Gitignore>,
    event: notify::Event,
) -> Vec<WorkspaceFsChange> {
    let mut changes: Vec<WorkspaceFsChange> = Vec::new();

    match event.kind {
        EventKind::Create(_) => {
            for path in event.paths {
                if should_skip_event_path(
                    root_path,
                    matcher,
                    &path,
                    maybe_is_dir(&path).unwrap_or(false),
                ) {
                    continue;
                }
                let Some(normalized) = normalize_event_path(&path, root_path, root_normalized)
                else {
                    continue;
                };
                changes.push(WorkspaceFsChange {
                    kind: WorkspaceFsChangeKind::Created,
                    parent: path_parent(&normalized),
                    path: Some(normalized),
                    old_path: None,
                    new_path: None,
                    old_parent: None,
                    new_parent: None,
                    is_dir: maybe_is_dir(&path),
                });
            }
        }
        EventKind::Remove(_) => {
            for path in event.paths {
                if should_skip_event_path(
                    root_path,
                    matcher,
                    &path,
                    maybe_is_dir(&path).unwrap_or(false),
                ) {
                    continue;
                }
                let Some(normalized) = normalize_event_path(&path, root_path, root_normalized)
                else {
                    continue;
                };
                changes.push(WorkspaceFsChange {
                    kind: WorkspaceFsChangeKind::Removed,
                    parent: path_parent(&normalized),
                    path: Some(normalized),
                    old_path: None,
                    new_path: None,
                    old_parent: None,
                    new_parent: None,
                    is_dir: maybe_is_dir(&path),
                });
            }
        }
        EventKind::Modify(ModifyKind::Name(rename_mode)) => match rename_mode {
            RenameMode::Both if event.paths.len() >= 2 => {
                let old_raw = &event.paths[0];
                let new_raw = &event.paths[1];
                if should_skip_event_path(
                    root_path,
                    matcher,
                    old_raw,
                    maybe_is_dir(old_raw).unwrap_or(false),
                ) || should_skip_event_path(
                    root_path,
                    matcher,
                    new_raw,
                    maybe_is_dir(new_raw).unwrap_or(false),
                ) {
                    return Vec::new();
                }

                let Some(old_path) = normalize_event_path(old_raw, root_path, root_normalized)
                else {
                    return Vec::new();
                };
                let Some(new_path) = normalize_event_path(new_raw, root_path, root_normalized)
                else {
                    return Vec::new();
                };

                changes.push(WorkspaceFsChange {
                    kind: WorkspaceFsChangeKind::Renamed,
                    old_parent: path_parent(&old_path),
                    new_parent: path_parent(&new_path),
                    old_path: Some(old_path),
                    new_path: Some(new_path),
                    path: None,
                    parent: None,
                    is_dir: maybe_is_dir(new_raw).or_else(|| maybe_is_dir(old_raw)),
                });
            }
            RenameMode::From => {
                for path in event.paths {
                    if should_skip_event_path(
                        root_path,
                        matcher,
                        &path,
                        maybe_is_dir(&path).unwrap_or(false),
                    ) {
                        continue;
                    }
                    let Some(normalized) = normalize_event_path(&path, root_path, root_normalized)
                    else {
                        continue;
                    };
                    changes.push(WorkspaceFsChange {
                        kind: WorkspaceFsChangeKind::Removed,
                        parent: path_parent(&normalized),
                        path: Some(normalized),
                        old_path: None,
                        new_path: None,
                        old_parent: None,
                        new_parent: None,
                        is_dir: maybe_is_dir(&path),
                    });
                }
            }
            RenameMode::To => {
                for path in event.paths {
                    if should_skip_event_path(
                        root_path,
                        matcher,
                        &path,
                        maybe_is_dir(&path).unwrap_or(false),
                    ) {
                        continue;
                    }
                    let Some(normalized) = normalize_event_path(&path, root_path, root_normalized)
                    else {
                        continue;
                    };
                    changes.push(WorkspaceFsChange {
                        kind: WorkspaceFsChangeKind::Created,
                        parent: path_parent(&normalized),
                        path: Some(normalized),
                        old_path: None,
                        new_path: None,
                        old_parent: None,
                        new_parent: None,
                        is_dir: maybe_is_dir(&path),
                    });
                }
            }
            _ => {}
        },
        EventKind::Modify(_) => {
            for path in event.paths {
                if should_skip_event_path(
                    root_path,
                    matcher,
                    &path,
                    maybe_is_dir(&path).unwrap_or(false),
                ) {
                    continue;
                }
                let Some(normalized) = normalize_event_path(&path, root_path, root_normalized)
                else {
                    continue;
                };
                changes.push(WorkspaceFsChange {
                    kind: WorkspaceFsChangeKind::Modified,
                    parent: path_parent(&normalized),
                    path: Some(normalized),
                    old_path: None,
                    new_path: None,
                    old_parent: None,
                    new_parent: None,
                    is_dir: maybe_is_dir(&path),
                });
            }
        }
        _ => {}
    }

    changes
}

pub(crate) fn start_workspace_watcher(app_handle: AppHandle, root_path: PathBuf) -> Result<()> {
    let root_canonical = fs::canonicalize(&root_path)?;
    let root_normalized = normalize_slashes(&root_canonical);

    let mut state = watcher_state()
        .lock()
        .map_err(|_| AppError::OperationFailed)?;

    state.watcher = None;
    state.session_id = state.session_id.saturating_add(1);
    state.root = Some(root_canonical.clone());
    let session_id = state.session_id;

    let callback_app_handle = app_handle.clone();
    let callback_root = root_canonical.clone();
    let callback_root_normalized = root_normalized.clone();
    let callback_ignore_matcher = build_ignore_matcher(&root_canonical).map(Arc::new);

    let mut watcher = notify::recommended_watcher(move |result: notify::Result<notify::Event>| {
        let Ok(event) = result else {
            return;
        };

        handle_notify_event(
            &callback_app_handle,
            session_id,
            &callback_root,
            &callback_root_normalized,
            callback_ignore_matcher.as_deref(),
            event,
        );
    })
    .map_err(|err| {
        AppError::InvalidOperation(format!("Could not start workspace watcher: {err}"))
    })?;

    watcher
        .watch(&root_canonical, RecursiveMode::Recursive)
        .map_err(|err| AppError::InvalidOperation(format!("Could not watch workspace: {err}")))?;

    state.watcher = Some(watcher);
    Ok(())
}

pub(crate) fn stop_workspace_watcher() -> Result<()> {
    let mut state = watcher_state()
        .lock()
        .map_err(|_| AppError::OperationFailed)?;
    state.watcher = None;
    state.root = None;
    Ok(())
}

#[cfg(test)]
mod tests {
    use std::{
        fs,
        path::PathBuf,
        time::{SystemTime, UNIX_EPOCH},
    };

    use notify::event::{CreateKind, ModifyKind, RemoveKind, RenameMode};
    use notify::Event;

    use super::*;

    fn unique_test_dir() -> PathBuf {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .map(|value| value.as_nanos())
            .unwrap_or(0);
        std::env::temp_dir().join(format!("tomosona-watch-tests-{now}"))
    }

    fn mk_root() -> (PathBuf, String) {
        let root = unique_test_dir();
        fs::create_dir_all(&root).expect("create test root");
        let root_normalized = normalize_slashes(&root);
        (root, root_normalized)
    }

    fn test_event(kind: EventKind, paths: Vec<PathBuf>) -> Event {
        Event {
            kind,
            paths,
            attrs: Default::default(),
        }
    }

    #[test]
    fn root_contains_path_checks_boundary() {
        assert!(root_contains_path("/ws", "/ws"));
        assert!(root_contains_path("/ws", "/ws/a.md"));
        assert!(!root_contains_path("/ws", "/wsx/a.md"));
    }

    #[test]
    fn should_skip_path_skips_internal_dirs_and_db_files() {
        assert!(should_skip_path(Path::new("/ws/.tomosona/state.json")));
        assert!(should_skip_path(Path::new("/ws/.tomosona-trash/item.md")));
        assert!(should_skip_path(Path::new("/ws/tomosona.sqlite")));
        assert!(should_skip_path(Path::new("/ws/tomosona.sqlite-wal")));
        assert!(!should_skip_path(Path::new("/ws/notes/file.md")));
    }

    #[test]
    fn gitignore_rules_filter_watcher_events() {
        let (root, root_norm) = mk_root();
        fs::write(root.join(".gitignore"), "ignored.md\n").expect("write gitignore");
        let matcher = build_ignore_matcher(&root);
        let ignored = root.join("ignored.md");
        fs::write(&ignored, "x").expect("write ignored file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            matcher.as_ref(),
            test_event(EventKind::Create(CreateKind::Any), vec![ignored]),
        );

        assert!(changes.is_empty());
    }

    #[test]
    fn tomosonaignore_rules_filter_watcher_events() {
        let (root, root_norm) = mk_root();
        fs::write(root.join(".tomosonaignore"), "private/**\n").expect("write tomosonaignore");
        fs::create_dir_all(root.join("private")).expect("create private dir");
        let matcher = build_ignore_matcher(&root);
        let ignored = root.join("private/secret.md");
        fs::write(&ignored, "x").expect("write ignored file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            matcher.as_ref(),
            test_event(EventKind::Create(CreateKind::Any), vec![ignored]),
        );

        assert!(changes.is_empty());
    }

    #[test]
    fn maps_create_event_for_absolute_path() {
        let (root, root_norm) = mk_root();
        let file = root.join("notes/new.md");
        fs::create_dir_all(file.parent().expect("parent")).expect("create parent");
        fs::write(&file, "hello").expect("create file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(EventKind::Create(CreateKind::Any), vec![file.clone()]),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Created);
        assert_eq!(changes[0].path, Some(normalize_slashes(&file)));
        assert_eq!(
            changes[0].parent,
            Some(normalize_slashes(file.parent().expect("parent")))
        );
    }

    #[test]
    fn maps_create_event_for_relative_path() {
        let (root, root_norm) = mk_root();
        let relative = PathBuf::from("nested/file.md");
        let absolute = root.join(&relative);
        fs::create_dir_all(absolute.parent().expect("parent")).expect("create parent");
        fs::write(&absolute, "ok").expect("create file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(EventKind::Create(CreateKind::Any), vec![relative]),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].path, Some(normalize_slashes(&absolute)));
    }

    #[test]
    fn ignores_paths_outside_workspace_root() {
        let (root, root_norm) = mk_root();
        let external = PathBuf::from("/tmp/somewhere-else.md");
        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(EventKind::Create(CreateKind::Any), vec![external]),
        );
        assert!(changes.is_empty());
    }

    #[test]
    fn maps_remove_event() {
        let (root, root_norm) = mk_root();
        let removed = root.join("gone.md");
        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(EventKind::Remove(RemoveKind::Any), vec![removed.clone()]),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Removed);
        assert_eq!(changes[0].path, Some(normalize_slashes(&removed)));
    }

    #[test]
    fn maps_rename_both_event() {
        let (root, root_norm) = mk_root();
        let old_path = root.join("old.md");
        let new_path = root.join("new.md");
        fs::write(&new_path, "renamed").expect("create renamed file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(
                EventKind::Modify(ModifyKind::Name(RenameMode::Both)),
                vec![old_path.clone(), new_path.clone()],
            ),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Renamed);
        assert_eq!(changes[0].old_path, Some(normalize_slashes(&old_path)));
        assert_eq!(changes[0].new_path, Some(normalize_slashes(&new_path)));
        assert_eq!(changes[0].old_parent, Some(root_norm.clone()));
        assert_eq!(changes[0].new_parent, Some(root_norm));
    }

    #[test]
    fn maps_rename_from_event_as_removed() {
        let (root, root_norm) = mk_root();
        let old_path = root.join("old.md");
        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(
                EventKind::Modify(ModifyKind::Name(RenameMode::From)),
                vec![old_path.clone()],
            ),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Removed);
        assert_eq!(changes[0].path, Some(normalize_slashes(&old_path)));
    }

    #[test]
    fn maps_rename_to_event_as_created() {
        let (root, root_norm) = mk_root();
        let new_path = root.join("new.md");
        fs::write(&new_path, "created").expect("create file");
        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(
                EventKind::Modify(ModifyKind::Name(RenameMode::To)),
                vec![new_path.clone()],
            ),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Created);
        assert_eq!(changes[0].path, Some(normalize_slashes(&new_path)));
    }

    #[test]
    fn rename_both_returns_empty_when_path_is_skipped() {
        let (root, root_norm) = mk_root();
        let old_path = root.join(".tomosona/old.md");
        let new_path = root.join("new.md");
        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(
                EventKind::Modify(ModifyKind::Name(RenameMode::Both)),
                vec![old_path, new_path],
            ),
        );
        assert!(changes.is_empty());
    }

    #[test]
    fn maps_non_name_modify_event() {
        let (root, root_norm) = mk_root();
        let file = root.join("notes/changed.md");
        fs::create_dir_all(file.parent().expect("parent")).expect("create parent");
        fs::write(&file, "updated").expect("create file");

        let changes = map_notify_event_to_changes(
            &root,
            &root_norm,
            None,
            test_event(EventKind::Modify(ModifyKind::Any), vec![file.clone()]),
        );

        assert_eq!(changes.len(), 1);
        assert_eq!(changes[0].kind, WorkspaceFsChangeKind::Modified);
        assert_eq!(changes[0].path, Some(normalize_slashes(&file)));
    }
}
